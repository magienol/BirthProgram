function _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }
import { Button } from '@dhis2-ui/button';
import { fireEvent, render, waitFor, within } from '@testing-library/react';
import { userEvent } from '@testing-library/user-event';
import React, { useState } from 'react';
import { Field, Form } from 'react-final-form';
import { CalendarInput } from '../calendar-input.js';
describe('Calendar Input', () => {
  beforeEach(() => {
    jest.useFakeTimers();
    jest.setSystemTime(new Date('2024-10-22T09:05:00.000Z'));
  });
  afterEach(jest.useRealTimers);
  it('allow selection of a date through the calendar widget', async () => {
    const onDateSelectMock = jest.fn();
    const screen = render(/*#__PURE__*/React.createElement(CalendarInput, {
      calendar: "gregory",
      onDateSelect: onDateSelectMock
    }));
    const dateInput = within(screen.getByTestId('dhis2-uicore-input')).getByRole('textbox');
    fireEvent.focus(dateInput);
    const calendar = await screen.findByTestId('calendar');
    expect(calendar).toBeInTheDocument();
    const todayString = '2024-10-22';
    const today = within(calendar).getByTestId(todayString);
    fireEvent.click(today);
    await waitFor(() => {
      expect(calendar).not.toBeInTheDocument();
    });
    expect(onDateSelectMock).toHaveBeenCalledWith(expect.objectContaining({
      calendarDateString: todayString
    }));
  });
  it('allow selection of a date through the input', async () => {
    const onDateSelectMock = jest.fn();
    const screen = render(/*#__PURE__*/React.createElement(CalendarInput, {
      calendar: "gregory",
      onDateSelect: onDateSelectMock
    }));
    const dateInputString = '2024/10/12';
    const dateInput = within(screen.getByTestId('dhis2-uicore-input')).getByRole('textbox');
    fireEvent.change(dateInput, {
      target: {
        value: dateInputString
      }
    });
    fireEvent.blur(dateInput);
    expect(onDateSelectMock).toHaveBeenCalledWith(expect.objectContaining({
      calendarDateString: dateInputString
    }));
  });
  describe('validation', () => {
    beforeEach(jest.useRealTimers);
    it('should validate minimum date', async () => {
      const onDateSelectMock = jest.fn();
      const screen = render(/*#__PURE__*/React.createElement(CalendarWithValidation, {
        calendar: "gregory",
        minDate: "2024-01-01",
        onDateSelect: onDateSelectMock
      }));
      const dateInputString = '2023-10-12';
      const dateInput = within(screen.getByTestId('dhis2-uicore-input')).getByRole('textbox');
      await userEvent.clear(dateInput);
      await userEvent.type(dateInput, dateInputString);
      await userEvent.tab();
      expect(await screen.findByText('Date 2023-10-12 is less than the minimum allowed date 2024-01-01.'));
      expect(onDateSelectMock).toHaveBeenCalledTimes(1);
    });
    it('should validate maximum date', async () => {
      const {
        getByTestId,
        findByText
      } = render(/*#__PURE__*/React.createElement(CalendarWithValidation, {
        calendar: "gregory",
        maxDate: "2024-01-01"
      }));
      const dateInputString = '2024-10-12';
      const dateInput = within(getByTestId('dhis2-uicore-input')).getByRole('textbox');
      await userEvent.clear(dateInput);
      await userEvent.type(dateInput, dateInputString);
      await userEvent.tab();
      expect(await findByText('Date 2024-10-12 is greater than the maximum allowed date 2024-01-01.'));
    });
    it('should validate date in ethiopic calendar', async () => {
      const onDateSelectMock = jest.fn();
      const {
        getByTestId,
        findByText,
        queryByText
      } = render(/*#__PURE__*/React.createElement(CalendarWithValidation, {
        calendar: "ethiopian",
        minDate: "2018-13-04",
        onDateSelect: onDateSelectMock
      }));
      let dateInputString = '2018-13-02';
      const dateInput = within(getByTestId('dhis2-uicore-input')).getByRole('textbox');
      await userEvent.clear(dateInput);
      await userEvent.type(dateInput, dateInputString);
      await userEvent.tab();
      await findByText('Date 2018-13-02 is less than the minimum allowed date 2018-13-04.');
      dateInputString = '2018-13-05';
      await userEvent.clear(dateInput);
      await userEvent.click(dateInput);
      await userEvent.type(dateInput, dateInputString);
      await userEvent.tab();
      expect(queryByText('Date 2018-13-04 is less than the minimum allowed date 2018-13-05.')).not.toBeInTheDocument();
      dateInputString = '2018-13-07';
      await userEvent.clear(dateInput);
      await userEvent.type(dateInput, dateInputString);
      await userEvent.tab();
      expect(await findByText('Invalid date in specified calendar')).toBeInTheDocument();
    }, 20 * 1000);
    // ToDo: these scenarios seem to work but they timeout on CI sporadically - ticket: https://dhis2.atlassian.net/browse/LIBS-763
    it.skip('should validate date in nepali calendar', async () => {
      const onDateSelectMock = jest.fn();
      const {
        getByTestId,
        findByText,
        queryByText
      } = render(/*#__PURE__*/React.createElement(CalendarWithValidation, {
        calendar: "nepali",
        maxDate: "2080-05-30",
        onDateSelect: onDateSelectMock
      }));
      let dateInputString = '2080-06-01';
      const dateInput = within(getByTestId('dhis2-uicore-input')).getByRole('textbox');
      await userEvent.clear(dateInput);
      await userEvent.type(dateInput, dateInputString);
      await userEvent.tab();
      expect(await findByText('Date 2080-06-01 is greater than the maximum allowed date 2080-05-30.'));
      dateInputString = '2080-04-32';
      await userEvent.clear(dateInput);
      await userEvent.type(dateInput, dateInputString);
      await userEvent.tab();
      expect(queryByText(/greater than the maximum allowed date/)).not.toBeInTheDocument();
      dateInputString = '2080-01-32';
      await userEvent.clear(dateInput);
      await userEvent.type(dateInput, dateInputString);
      await userEvent.tab();
      expect(await findByText('Invalid date in specified calendar')).toBeInTheDocument();
    }, 20 * 1000);
    it.skip('should validate from date picker', async () => {
      jest.useFakeTimers('modern');
      jest.setSystemTime(new Date('2024-10-22T09:05:00.000Z'));
      const onDateSelectMock = jest.fn();
      const {
        queryByText,
        getByText,
        getByTestId
      } = render(/*#__PURE__*/React.createElement(CalendarWithValidation, {
        calendar: "gregory",
        minDate: "2024-02-16",
        onDateSelect: onDateSelectMock
      }));
      const dateInput = within(getByTestId('dhis2-uicore-input')).getByRole('textbox');
      await fireEvent.focusIn(dateInput);
      await fireEvent.click(getByText('17'));
      expect(queryByText('17')).not.toBeInTheDocument();

      // Checking fix for Bug where callback used to be called twice - first with undefined
      expect(onDateSelectMock).toHaveBeenCalledTimes(1);
      expect(onDateSelectMock).toHaveBeenCalledWith({
        calendarDateString: '2024-10-17',
        validation: {
          error: false,
          valid: true,
          warning: false
        }
      });
    });
    it('should validate with Clear', async () => {
      const onDateSelectMock = jest.fn();
      const {
        queryByText,
        getByText,
        getByTestId
      } = render(/*#__PURE__*/React.createElement(CalendarWithValidation, {
        calendar: "gregory",
        minDate: "2024-02-16",
        onDateSelect: onDateSelectMock,
        clearable: true
      }));
      const dateInputString = '2023-10-12';
      const dateInput = within(getByTestId('dhis2-uicore-input')).getByRole('textbox');
      await userEvent.clear(dateInput);
      await userEvent.type(dateInput, dateInputString);
      await userEvent.tab();
      expect(getByTestId('dhis2-uiwidgets-calendar-inputfield-validation')).toBeInTheDocument();
      await userEvent.click(getByText('Clear'));
      expect(queryByText('17')).not.toBeInTheDocument();
      expect(onDateSelectMock).toHaveBeenLastCalledWith({
        calendarDateString: null,
        validation: {
          valid: true
        }
      });
    });
    it('should validate when Clearing manually (i.e. deleting text not using clear button)', async () => {
      const onDateSelectMock = jest.fn();
      const {
        getByTestId
      } = render(/*#__PURE__*/React.createElement(CalendarWithValidation, {
        calendar: "gregory",
        minDate: "2024-02-16",
        onDateSelect: onDateSelectMock,
        clearable: true
      }));
      const dateInputString = '2023-10-12';
      const dateInput = within(getByTestId('dhis2-uicore-input')).getByRole('textbox');
      await userEvent.clear(dateInput);
      await userEvent.type(dateInput, dateInputString);
      await userEvent.tab();
      expect(getByTestId('dhis2-uiwidgets-calendar-inputfield-validation')).toBeInTheDocument();
      await userEvent.clear(dateInput);
      await userEvent.tab();
      expect(onDateSelectMock).toHaveBeenCalledWith({
        calendarDateString: null,
        validation: {
          valid: true
        }
      });
    });
  });
});
const CalendarWithValidation = propsFromParent => {
  const [date, setDate] = useState();
  const [validation, setValidation] = useState({});
  const errored = () => {
    if (validation !== null && validation !== void 0 && validation.error) {
      return {
        calendar: validation.validationText
      };
    }
  };
  return /*#__PURE__*/React.createElement(Form, {
    onSubmit: () => {},
    validate: errored
  }, _ref => {
    let {
      handleSubmit,
      invalid
    } = _ref;
    return /*#__PURE__*/React.createElement("form", null, /*#__PURE__*/React.createElement(Field, {
      name: "calendar"
    }, props => /*#__PURE__*/React.createElement(CalendarInput, _extends({}, props, {
      date: date,
      label: "Enter a date",
      editable: true,
      calendar: "gregory"
    }, validation, propsFromParent, {
      onDateSelect: date => {
        var _propsFromParent$onDa;
        setDate(date === null || date === void 0 ? void 0 : date.calendarDateString);
        setValidation(date === null || date === void 0 ? void 0 : date.validation);
        (_propsFromParent$onDa = propsFromParent.onDateSelect) === null || _propsFromParent$onDa === void 0 ? void 0 : _propsFromParent$onDa.call(propsFromParent, date);
      }
    }))), /*#__PURE__*/React.createElement(Button, {
      type: "submit",
      disabled: invalid,
      onClick: handleSubmit
    }, "Submit"));
  });
};