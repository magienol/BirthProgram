import _JSXStyle from "styled-jsx/style";
function _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }
import { useDatePicker, useResolvedDirection, validateDateString } from '@dhis2/multi-calendar-dates';
import { Button } from '@dhis2-ui/button';
import { Card } from '@dhis2-ui/card';
import { InputField } from '@dhis2-ui/input';
import { Layer } from '@dhis2-ui/layer';
import { Popper } from '@dhis2-ui/popper';
import cx from 'classnames';
import PropTypes from 'prop-types';
import React, { useRef, useState, useMemo, useEffect } from 'react';
import { CalendarContainer } from '../calendar/calendar-container.js';
import i18n from '../locales/index.js';
const offsetModifier = {
  name: 'offset',
  options: {
    offset: [0, 2]
  }
};
export const CalendarInput = function () {
  let {
    onDateSelect: parentOnDateSelect,
    calendar,
    date,
    dir,
    locale,
    numberingSystem,
    weekDayFormat = 'narrow',
    width = '300px',
    cellSize = '32px',
    clearable,
    minDate,
    maxDate,
    format,
    strictValidation,
    inputWidth,
    dataTest = 'dhis2-uiwidgets-calendar-inputfield',
    pastOnly,
    ...rest
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  const ref = useRef();
  const calendarRef = useRef();
  const [open, setOpen] = useState(false);
  const [partialDate, setPartialDate] = useState(date);
  useEffect(() => setPartialDate(date), [date]);
  const useDatePickerOptions = useMemo(() => ({
    calendar,
    locale,
    numberingSystem,
    weekDayFormat,
    pastOnly
  }), [calendar, locale, numberingSystem, weekDayFormat, pastOnly]);
  const onChooseDate = (date, validationOptions) => {
    if (!date) {
      parentOnDateSelect === null || parentOnDateSelect === void 0 ? void 0 : parentOnDateSelect({
        calendarDateString: null,
        validation: {
          valid: true
        }
      });
      return;
    }
    const validation = validateDateString(date, validationOptions);
    parentOnDateSelect === null || parentOnDateSelect === void 0 ? void 0 : parentOnDateSelect({
      calendarDateString: date,
      validation
    });
  };
  const validationOptions = useMemo(() => ({
    calendar,
    format,
    minDateString: minDate,
    maxDateString: maxDate,
    strictValidation
  }), [calendar, format, maxDate, minDate, strictValidation]);
  const pickerResults = useDatePicker({
    onDateSelect: result => {
      onChooseDate(result.calendarDateString, validationOptions);
      setOpen(false);
    },
    date,
    ...validationOptions,
    options: useDatePickerOptions
  });
  const handleChange = e => {
    setOpen(false);
    setPartialDate(e.value);
  };
  const handleBlur = (_, e) => {
    var _calendarRef$current;
    if (e.relatedTarget && (_calendarRef$current = calendarRef.current) !== null && _calendarRef$current !== void 0 && _calendarRef$current.contains(e.relatedTarget)) {
      return;
    }
    onChooseDate(partialDate, validationOptions);
    setOpen(false);
  };
  const onFocus = () => {
    var _rest$onFocus;
    setOpen(true);
    rest === null || rest === void 0 ? void 0 : (_rest$onFocus = rest.onFocus) === null || _rest$onFocus === void 0 ? void 0 : _rest$onFocus.call(rest);
  };
  const languageDirection = useResolvedDirection(dir, locale);
  const calendarProps = useMemo(() => ({
    date,
    width,
    cellSize,
    isValid: pickerResults.isValid,
    calendarWeekDays: pickerResults.calendarWeekDays,
    weekDayLabels: pickerResults.weekDayLabels,
    currMonth: pickerResults.currMonth,
    currYear: pickerResults.currYear,
    nextMonth: pickerResults.nextMonth,
    nextYear: pickerResults.nextYear,
    prevMonth: pickerResults.prevMonth,
    prevYear: pickerResults.prevYear,
    navigateToYear: pickerResults.navigateToYear,
    navigateToMonth: pickerResults.navigateToMonth,
    months: pickerResults.months,
    years: pickerResults.years,
    languageDirection
  }), [cellSize, date, pickerResults, width, languageDirection]);
  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("div", {
    ref: ref,
    className: _JSXStyle.dynamic([["423137534", [inputWidth, rest.error || rest.warning ? '36px' : '6px']]]) + " " + "calendar-input-wrapper"
  }, /*#__PURE__*/React.createElement(InputField, _extends({
    label: i18n.t('Pick a date')
  }, rest, {
    dataTest: dataTest,
    type: "text",
    onFocus: onFocus,
    value: partialDate,
    onChange: handleChange,
    onBlur: handleBlur,
    inputWidth: inputWidth
  })), clearable && /*#__PURE__*/React.createElement("div", {
    className: _JSXStyle.dynamic([["423137534", [inputWidth, rest.error || rest.warning ? '36px' : '6px']]]) + " " + (cx('calendar-clear-button', {
      'with-icon': rest.valid || rest.error || rest.warning || rest.loading,
      'with-dense-wrapper': rest.dense
    }) || "")
  }, /*#__PURE__*/React.createElement(Button, {
    dataTest: "calendar-clear-button",
    secondary: true,
    small: true,
    onClick: () => onChooseDate(null),
    type: "button"
  }, i18n.t('Clear')))), open && /*#__PURE__*/React.createElement(Layer, {
    onBackdropClick: () => setOpen(false)
  }, /*#__PURE__*/React.createElement(Popper, {
    reference: ref,
    placement: "bottom-start",
    modifiers: [offsetModifier]
  }, /*#__PURE__*/React.createElement(Card, null, /*#__PURE__*/React.createElement(CalendarContainer, _extends({}, calendarProps, {
    calendarRef: calendarRef
  }))))), /*#__PURE__*/React.createElement(_JSXStyle, {
    id: "423137534",
    dynamic: [inputWidth, rest.error || rest.warning ? '36px' : '6px']
  }, [`.calendar-input-wrapper.__jsx-style-dynamic-selector{position:relative;width:${inputWidth};}`, `.calendar-clear-button.__jsx-style-dynamic-selector{position:absolute;inset-inline-end:${rest.error || rest.warning ? '36px' : '6px'};-webkit-inset-block-start:27px;-ms-intb-rlock-start:27px;inset-block-start:27px;}`, ".calendar-clear-button.with-icon.__jsx-style-dynamic-selector{inset-inline-end:36px;}", ".calendar-clear-button.with-dense-wrapper.__jsx-style-dynamic-selector{-webkit-inset-block-start:23px;-ms-intb-rlock-start:23px;inset-block-start:23px;}"]));
};
CalendarInput.propTypes = {
  /** the calendar to use such gregory, ethiopic, nepali - full supported list here: https://github.com/dhis2/multi-calendar-dates/blob/main/src/constants/calendars.ts  */
  calendar: PropTypes.any.isRequired,
  /** Called with signature `(null)` \|\| `({ dateCalendarString: string, validation: { error: boolean, warning: boolean, validationText: string} })` with `dateCalendarString` being the stringified date in the specified calendar in the format `yyyy-MM-dd` */
  onDateSelect: PropTypes.func.isRequired,
  /** the size of a single cell in the table forming the calendar */
  cellSize: PropTypes.string,
  /** Whether the clear button is displayed */
  clearable: PropTypes.bool,
  /** 'data-test' attribute of `InputField` component */
  dataTest: PropTypes.string,
  /** the currently selected date using an iso-like format YYYY-MM-DD, in the calendar system provided (not iso8601) */
  date: PropTypes.string,
  /** the direction of the library - internally the library will use rtl for rtl-languages but this can be overridden here for more control */
  dir: PropTypes.oneOf(['ltr', 'rtl']),
  /** The date format to use either `YYYY-MM-DD` or `DD-MM-YYYY` */
  format: PropTypes.oneOf(['YYYY-MM-DD', 'DD-MM-YYYY']),
  /** the width of input field */
  inputWidth: PropTypes.string,
  /** any valid locale -  if none provided, the internal library will fallback to the user locale (more info here: https://github.com/dhis2/multi-calendar-dates/blob/main/src/hooks/internal/useResolvedLocaleOptions.ts#L15) */
  locale: PropTypes.string,
  /** The maximum selectable date */
  maxDate: PropTypes.string,
  /** The minimum selectable date */
  minDate: PropTypes.string,
  /** numbering system to use - full list here https://github.com/dhis2/multi-calendar-dates/blob/main/src/constants/numberingSystems.ts */
  numberingSystem: PropTypes.string,
  /** When true, only shows years in the past (current year and earlier) */
  pastOnly: PropTypes.bool,
  /** Whether to use strict validation by showing errors for out-of-range dates when enabled (default), and warnings when disabled */
  strictValidation: PropTypes.bool,
  /** the format to display for the week day, i.e. Monday (long), Mon (short), M (narrow) */
  weekDayFormat: PropTypes.oneOf(['narrow', 'short', 'long']),
  /** the width of the calendar component */
  width: PropTypes.string
};