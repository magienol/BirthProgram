"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.WithValue = exports.WithHelpText = exports.ValueTextOverflow = exports.StatusWarning = exports.StatusValid = exports.StatusLoading = exports.StatusError = exports.Required = exports.ReadOnly = exports.PlaceholderNoValue = exports.NoPlaceholderNoValue = exports.LabelTextOverflow = exports.InputWithPrefixIcon = exports.InputWidth = exports.Focus = exports.Disabled = exports.Dense = exports.Default = exports.ClearableInput = void 0;
var _uiConstants = require("@dhis2/ui-constants");
var _uiIcons = require("@dhis2/ui-icons");
var _react = _interopRequireWildcard(require("react"));
var _index = require("./index.js");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }
const subtitle = 'Allows a user to enter data, usually text';
const description = `
Inputs are used wherever a user needs to input standard text information. Inputs are often used as part of forms. An input can also be used to capture information outside of a form, perhaps as a 'Filter' or 'Search' field.

InputField wraps an Input component with a label, help text, validation text, and some other features.

Please see more about options and features of inputs at [Design System: Input Field](https://github.com/dhis2/design-system/blob/master/atoms/inputfield.md#input).

\`\`\`js
import { InputField } from '@dhis2/ui'
\`\`\`
`;
const logger = _ref => {
  let {
    name,
    value
  } = _ref;
  return console.log(`Name: ${name}, value: ${value}`);
};
const inputTypeArgType = {
  table: {
    type: {
      summary: 'string'
    }
  },
  control: {
    type: 'select',
    options: ['text', 'number', 'password', 'email', 'url', 'tel', 'date', 'datetime', 'datetime-local', 'month', 'week', 'time', 'search']
  }
};
var _default = exports.default = {
  title: 'Input Field',
  component: _index.InputField,
  parameters: {
    componentSubtitle: subtitle,
    docs: {
      description: {
        component: description
      }
    }
  },
  // Default args
  args: {
    label: 'Default label',
    name: 'defaultName',
    onChange: logger
  },
  argTypes: {
    type: {
      ...inputTypeArgType
    },
    valid: {
      ..._uiConstants.sharedPropTypes.statusArgType
    },
    warning: {
      ..._uiConstants.sharedPropTypes.statusArgType
    },
    error: {
      ..._uiConstants.sharedPropTypes.statusArgType
    }
  }
};
const Template = args => /*#__PURE__*/_react.default.createElement(_index.InputField, args);
const Default = exports.Default = Template.bind({});
const NoPlaceholderNoValue = exports.NoPlaceholderNoValue = Template.bind({});
NoPlaceholderNoValue.storyName = 'No placeholder, no value';
const PlaceholderNoValue = exports.PlaceholderNoValue = Template.bind({});
PlaceholderNoValue.args = {
  placeholder: 'Hold the place'
};
PlaceholderNoValue.storyName = 'Placeholder, no value';
const WithHelpText = exports.WithHelpText = Template.bind({});
WithHelpText.args = {
  ...PlaceholderNoValue.args,
  helpText: 'With some helping text to guide the user along'
};
const WithValue = exports.WithValue = Template.bind({});
WithValue.args = {
  value: 'This is set through the value prop, which means the component is controlled.'
};
const Focus = exports.Focus = Template.bind({});
Focus.args = {
  initialFocus: true
};
// Disabled initial focus stories on docs page
Focus.parameters = {
  docs: {
    disable: true
  }
};
const StatusValid = exports.StatusValid = Template.bind({});
StatusValid.args = {
  valid: true,
  value: 'This value is valid'
};
StatusValid.storyName = 'Status: Valid';
const StatusWarning = exports.StatusWarning = Template.bind({});
StatusWarning.args = {
  warning: true,
  value: 'This value produces a warning'
};
StatusWarning.storyName = 'Status: Warning';
const StatusError = exports.StatusError = Template.bind({});
StatusError.args = {
  error: true,
  value: 'This value produces an error',
  helpText: 'This is some help text to advise what this input actually is.',
  validationText: 'This validation text describes the error, if a message is supplied.'
};
StatusError.storyName = 'Status: Error';
const StatusLoading = exports.StatusLoading = Template.bind({});
StatusLoading.args = {
  loading: true,
  value: 'This value produces a loading state'
};
StatusLoading.storyName = 'Status: Loading';
const Disabled = exports.Disabled = Template.bind({});
Disabled.args = {
  disabled: true,
  value: 'This field is disabled'
};
const ReadOnly = exports.ReadOnly = Template.bind({});
ReadOnly.args = {
  readOnly: true,
  value: 'This field is read-only'
};
const Dense = exports.Dense = Template.bind({});
Dense.args = {
  dense: true,
  value: 'This field is dense'
};
const InputWidth = args => /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(_index.InputField, _extends({}, args, {
  name: "input1",
  label: "My inputField has a width of 100px",
  inputWidth: "100px"
})), /*#__PURE__*/_react.default.createElement(_index.InputField, _extends({}, args, {
  name: "input2",
  label: "My inputField has a width of 220px",
  inputWidth: "220px"
})));
exports.InputWidth = InputWidth;
const LabelTextOverflow = exports.LabelTextOverflow = Template.bind({});
LabelTextOverflow.args = {
  dense: true,
  warning: true,
  label: "This label is too long to show on a single line of the input field's label. We just let it flow to the next line so the user can still read it. However, we should always aim to keep it shorter than this!"
};
const ValueTextOverflow = exports.ValueTextOverflow = Template.bind({});
ValueTextOverflow.args = {
  value: "This value is too long in order to show on a single line of the input field. It should stay on one line, not in an extra line and which wouldn't look like a standard input",
  dense: true,
  warning: true
};
const Required = exports.Required = Template.bind({});
Required.args = {
  required: true
};
const InputWithPrefixIcon = args => /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(_index.InputField, _extends({}, args, {
  name: "prefix-icon-input",
  label: "Search",
  placeholder: 'Search',
  prefixIcon: /*#__PURE__*/_react.default.createElement(_uiIcons.IconSearch16, null)
})), /*#__PURE__*/_react.default.createElement(_index.InputField, _extends({}, args, {
  name: "prefix-icon-input",
  label: "Location",
  placeholder: 'Enter Location',
  prefixIcon: /*#__PURE__*/_react.default.createElement(_uiIcons.IconLocation16, null),
  inputWidth: '200px'
})));
exports.InputWithPrefixIcon = InputWithPrefixIcon;
const ClearableInput = args => {
  const [value, setValue] = (0, _react.useState)('value');
  return /*#__PURE__*/_react.default.createElement(_index.InputField, _extends({}, args, {
    name: "clearable-input",
    label: "This field can be cleared",
    placeholder: '',
    onChange: e => setValue(e.value),
    clearable: true,
    clearText: () => setValue(''),
    value: value
  }));
};
exports.ClearableInput = ClearableInput;