"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validateDateString = exports.DateValidationResult = void 0;
var _d2I18n = _interopRequireDefault(require("@dhis2/d2-i18n"));
var _polyfill = require("@js-temporal/polyfill");
var _dhis2CalendarsMap = require("../constants/dhis2CalendarsMap");
var _extractDatePartsFromDateString = require("./extract-date-parts-from-date-string");
var _helpers = require("./helpers");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
let DateValidationResult;
exports.DateValidationResult = DateValidationResult;
(function (DateValidationResult) {
  DateValidationResult["INVALID_DATE_IN_CALENDAR"] = "INVALID_DATE_IN_CALENDAR";
  DateValidationResult["WRONG_FORMAT"] = "WRONG_FORMAT";
  DateValidationResult["LESS_THAN_MIN"] = "LESS_THAN_MIN";
  DateValidationResult["MORE_THAN_MAX"] = "INVALID_DATE_MORE_THAN_MAX";
})(DateValidationResult || (exports.DateValidationResult = DateValidationResult = {}));
const validateDateString = function (dateString) {
  var _dhis2CalendarsMap$ca;
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const {
    calendar = 'gregory',
    minDateString,
    maxDateString,
    strictValidation = true,
    format
  } = options;
  const resolvedCalendar = (0, _helpers.getCustomCalendarIfExists)((_dhis2CalendarsMap$ca = _dhis2CalendarsMap.dhis2CalendarsMap[calendar]) !== null && _dhis2CalendarsMap$ca !== void 0 ? _dhis2CalendarsMap$ca : calendar);

  // Will throw if the format of the date is incorrect
  if (!dateString) {
    return {
      valid: false,
      error: true,
      validationCode: DateValidationResult.WRONG_FORMAT,
      validationText: _d2I18n.default.t(`Date is not given`)
    };
  }
  let dateParts;
  try {
    dateParts = (0, _extractDatePartsFromDateString.extractDatePartsFromDateString)(dateString, format);
  } catch (e) {
    return {
      valid: false,
      error: true,
      validationCode: DateValidationResult.WRONG_FORMAT,
      validationText: e === null || e === void 0 ? void 0 : e.message
    };
  }
  let date;

  // Will throw if the year, month or day is out of range
  try {
    date = (0, _helpers.isCustomCalendar)(resolvedCalendar) ? _polyfill.Temporal.Calendar.from(resolvedCalendar).dateFromFields(dateParts, {
      overflow: 'reject'
    }) // need to be handled separately for custom calendars
    : _polyfill.Temporal.PlainDate.from({
      ...dateParts,
      calendar: resolvedCalendar
    }, {
      overflow: 'reject'
    });
  } catch (err) {
    return {
      valid: false,
      error: true,
      validationCode: DateValidationResult.INVALID_DATE_IN_CALENDAR,
      validationText: _d2I18n.default.t('Invalid date in specified calendar')
    };
  }
  const validationType = strictValidation ? {
    error: true,
    valid: false
  } : {
    warning: true,
    valid: true
  };
  if (minDateString) {
    const minDateParts = (0, _extractDatePartsFromDateString.extractDatePartsFromDateString)(minDateString);
    const minDate = _polyfill.Temporal.PlainDate.from({
      ...minDateParts,
      calendar: resolvedCalendar
    });
    if (_polyfill.Temporal.PlainDate.compare(date, minDate) < 0) {
      const result = {
        ...validationType,
        validationCode: DateValidationResult.LESS_THAN_MIN,
        validationText: _d2I18n.default.t(`Date {{dateString}} is less than the minimum allowed date {{minDateString}}.`, {
          dateString,
          minDateString
        })
      };
      return result;
    }
  }
  if (maxDateString) {
    const maxDateParts = (0, _extractDatePartsFromDateString.extractDatePartsFromDateString)(maxDateString);
    const maxDate = _polyfill.Temporal.PlainDate.from({
      ...maxDateParts,
      calendar: resolvedCalendar
    });
    if (_polyfill.Temporal.PlainDate.compare(date, maxDate) > 0) {
      const result = {
        ...validationType,
        validationCode: DateValidationResult.MORE_THAN_MAX,
        validationText: _d2I18n.default.t(`Date {{dateString}} is greater than the maximum allowed date {{maxDateString}}.`, {
          dateString,
          maxDateString
        })
      };
      return result;
    }
  }
  return {
    valid: true,
    error: false,
    warning: false
  };
};
exports.validateDateString = validateDateString;