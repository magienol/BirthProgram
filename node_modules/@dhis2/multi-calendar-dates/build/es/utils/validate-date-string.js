import i18n from '@dhis2/d2-i18n';
import { Temporal } from '@js-temporal/polyfill';
import { dhis2CalendarsMap } from '../constants/dhis2CalendarsMap';
import { extractDatePartsFromDateString } from './extract-date-parts-from-date-string';
import { getCustomCalendarIfExists, isCustomCalendar } from './helpers';
export let DateValidationResult;
(function (DateValidationResult) {
  DateValidationResult["INVALID_DATE_IN_CALENDAR"] = "INVALID_DATE_IN_CALENDAR";
  DateValidationResult["WRONG_FORMAT"] = "WRONG_FORMAT";
  DateValidationResult["LESS_THAN_MIN"] = "LESS_THAN_MIN";
  DateValidationResult["MORE_THAN_MAX"] = "INVALID_DATE_MORE_THAN_MAX";
})(DateValidationResult || (DateValidationResult = {}));
export const validateDateString = function (dateString) {
  var _dhis2CalendarsMap$ca;
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const {
    calendar = 'gregory',
    minDateString,
    maxDateString,
    strictValidation = true,
    format
  } = options;
  const resolvedCalendar = getCustomCalendarIfExists((_dhis2CalendarsMap$ca = dhis2CalendarsMap[calendar]) !== null && _dhis2CalendarsMap$ca !== void 0 ? _dhis2CalendarsMap$ca : calendar);

  // Will throw if the format of the date is incorrect
  if (!dateString) {
    return {
      valid: false,
      error: true,
      validationCode: DateValidationResult.WRONG_FORMAT,
      validationText: i18n.t(`Date is not given`)
    };
  }
  let dateParts;
  try {
    dateParts = extractDatePartsFromDateString(dateString, format);
  } catch (e) {
    return {
      valid: false,
      error: true,
      validationCode: DateValidationResult.WRONG_FORMAT,
      validationText: e === null || e === void 0 ? void 0 : e.message
    };
  }
  let date;

  // Will throw if the year, month or day is out of range
  try {
    date = isCustomCalendar(resolvedCalendar) ? Temporal.Calendar.from(resolvedCalendar).dateFromFields(dateParts, {
      overflow: 'reject'
    }) // need to be handled separately for custom calendars
    : Temporal.PlainDate.from({
      ...dateParts,
      calendar: resolvedCalendar
    }, {
      overflow: 'reject'
    });
  } catch (err) {
    return {
      valid: false,
      error: true,
      validationCode: DateValidationResult.INVALID_DATE_IN_CALENDAR,
      validationText: i18n.t('Invalid date in specified calendar')
    };
  }
  const validationType = strictValidation ? {
    error: true,
    valid: false
  } : {
    warning: true,
    valid: true
  };
  if (minDateString) {
    const minDateParts = extractDatePartsFromDateString(minDateString);
    const minDate = Temporal.PlainDate.from({
      ...minDateParts,
      calendar: resolvedCalendar
    });
    if (Temporal.PlainDate.compare(date, minDate) < 0) {
      const result = {
        ...validationType,
        validationCode: DateValidationResult.LESS_THAN_MIN,
        validationText: i18n.t(`Date {{dateString}} is less than the minimum allowed date {{minDateString}}.`, {
          dateString,
          minDateString
        })
      };
      return result;
    }
  }
  if (maxDateString) {
    const maxDateParts = extractDatePartsFromDateString(maxDateString);
    const maxDate = Temporal.PlainDate.from({
      ...maxDateParts,
      calendar: resolvedCalendar
    });
    if (Temporal.PlainDate.compare(date, maxDate) > 0) {
      const result = {
        ...validationType,
        validationCode: DateValidationResult.MORE_THAN_MAX,
        validationText: i18n.t(`Date {{dateString}} is greater than the maximum allowed date {{maxDateString}}.`, {
          dateString,
          maxDateString
        })
      };
      return result;
    }
  }
  return {
    valid: true,
    error: false,
    warning: false
  };
};