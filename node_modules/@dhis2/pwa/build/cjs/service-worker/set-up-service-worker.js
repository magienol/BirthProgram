"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setUpServiceWorker = setUpServiceWorker;
var _workboxPrecaching = require("workbox-precaching");
var _workboxRouting = require("workbox-routing");
var _workboxStrategies = require("workbox-strategies");
var _constants = require("../lib/constants.js");
var _dhis2ConnectionStatus = require("./dhis2-connection-status");
var _otherStrategies = require("./other-strategies.js");
var _recordingMode = require("./recording-mode.js");
var _utils = require("./utils.js");
function setUpServiceWorker() {
  const pwaEnabled = process.env.REACT_APP_DHIS2_APP_PWA_ENABLED === 'true';
  if (!pwaEnabled) {
    // Install 'killswitch' service worker and refresh page to clear
    // rogue service workers. App should then unregister SW
    (0, _utils.setUpKillSwitchServiceWorker)();
    return;
  }

  // Misc setup

  // Disable verbose logs
  // TODO: control with env var
  self.__WB_DISABLE_DEV_LOGS = true;

  // Globals (Note: global state resets each time SW goes idle)

  (0, _recordingMode.initClientRecordingStates)();
  (0, _dhis2ConnectionStatus.initDhis2ConnectionStatus)();

  // Local constants

  const PRODUCTION_ENV = process.env.NODE_ENV === 'production';
  const fileExtensionRegexp = new RegExp('/[^/?]+\\.[^/]+$');

  // Workbox routes

  // Only precache in production mode to enable easier app development.
  // In development, static assets are handled by 'network first' strategy
  // and will be kept up-to-date.
  if (PRODUCTION_ENV) {
    // Injection point for the precache manifest from workbox-build,
    // a manifest of app assets to fetch and cache upon SW installation
    const precacheManifest = self.__WB_MANIFEST || [];

    // todo: also do this routing for plugin.html
    // Extract index.html from the manifest to precache, then route
    // in a custom way
    const indexHtmlManifestEntry = precacheManifest.find(_ref => {
      let {
        url
      } = _ref;
      return url.endsWith('index.html');
    });
    // Make sure that this request doesn't redirect to a global shell
    indexHtmlManifestEntry.url += '?redirect=false';
    (0, _workboxPrecaching.precache)([indexHtmlManifestEntry]);

    // Custom strategy for handling app navigation, specifically to allow
    // navigations to redirect to the login page while online if the
    // user is unauthenticated. Fixes showing the app shell login dialog
    // in production if a user is online and unauthenticated.
    // Uses app-shell style routing to route navigations to index.html.
    const navigationRouteMatcher = _ref2 => {
      let {
        request,
        url
      } = _ref2;
      // If this isn't a navigation, skip.
      if (request.mode !== 'navigate') {
        return false;
      }

      // If this is a URL that starts with /_, skip.
      if (url.pathname.startsWith('/_')) {
        return false;
      }

      // If this looks like a URL for a resource, because it contains
      // a file extension, skip (unless it's index.html)
      if (fileExtensionRegexp.test(url.pathname) && !url.pathname.endsWith('index.html')) {
        return false;
      }

      // Return true to signal that we want to use the handler.
      return true;
    };
    // Above, the index entry had the redirect param added:
    const indexUrl = process.env.PUBLIC_URL + '/index.html?redirect=false';
    const navigationRouteHandler = _ref3 => {
      let {
        request
      } = _ref3;
      return fetch(request).then(response => {
        if (response.type === 'opaqueredirect' || !response.ok) {
          // It's sending a redirect to the login page,
          // or an 'unauthorized'/'forbidden' response.
          // Return that to the client
          return response;
        }

        // Otherwise return precached index.html
        return (0, _workboxPrecaching.matchPrecache)(indexUrl);
      }).catch(() => {
        // Request failed (probably offline). Return cached response
        return (0, _workboxPrecaching.matchPrecache)(indexUrl);
      });
    };
    // NOTE: This route must come before any precacheAndRoute calls, since
    // precacheAndRoute creates routes for ALL previously precached files
    (0, _workboxRouting.registerRoute)(navigationRouteMatcher, navigationRouteHandler);

    // Handle the rest of files in the manifest - filter out index.html
    const restOfManifest = precacheManifest.filter(e => e !== indexHtmlManifestEntry);
    (0, _workboxPrecaching.precacheAndRoute)(restOfManifest);
  }

  // Handling pings: only use the network, and don't update the connection
  // status (let the runtime do that)
  // Two endpoints: /api(/version)/system/ping and /api/ping
  (0, _workboxRouting.registerRoute)(_ref4 => {
    let {
      url
    } = _ref4;
    return /\/api(\/\d+)?(\/system)?\/ping/.test(url.pathname);
  }, new _workboxStrategies.NetworkOnly());

  // Request handler during recording mode: ALL requests are cached
  // Handling routing: https://developers.google.com/web/tools/workbox/modules/workbox-routing#matching_and_handling_in_routes
  (0, _workboxRouting.registerRoute)(_recordingMode.shouldRequestBeRecorded, new _recordingMode.RecordingMode({
    plugins: [_dhis2ConnectionStatus.dhis2ConnectionStatusPlugin]
  }));

  // If not recording, fall through to default caching strategies for app
  // shell:
  // SWR strategy for image assets that can't be precached.
  // (Skip in development environments)
  (0, _workboxRouting.registerRoute)(_ref5 => {
    let {
      url
    } = _ref5;
    return PRODUCTION_ENV && (0, _utils.urlMeetsAppShellCachingCriteria)(url) && /\.(jpg|gif|png|bmp|tiff|ico|woff)$/.test(url.pathname);
  }, new _workboxStrategies.StaleWhileRevalidate({
    cacheName: 'other-assets',
    plugins: [_dhis2ConnectionStatus.dhis2ConnectionStatusPlugin]
  }));

  // Network-first caching for everything else.
  // Uses a custom strategy in dev mode to avoid bloating cache
  // with file duplicates
  // * NOTE: there may be lazy-loading errors while offline in dev mode
  const ResolvedNetworkFirst = PRODUCTION_ENV ? _workboxStrategies.NetworkFirst : _otherStrategies.DevNetworkFirst;
  (0, _workboxRouting.registerRoute)(_ref6 => {
    let {
      url
    } = _ref6;
    return (0, _utils.urlMeetsAppShellCachingCriteria)(url);
  }, new ResolvedNetworkFirst({
    cacheName: 'app-shell',
    plugins: [_dhis2ConnectionStatus.dhis2ConnectionStatusPlugin]
  }));

  // Fallback: try cache if network fails, but don't cache anything
  (0, _workboxRouting.setDefaultHandler)(new _otherStrategies.NetworkAndTryCache({
    plugins: [_dhis2ConnectionStatus.dhis2ConnectionStatusPlugin]
  }));

  // Service Worker event handlers

  self.addEventListener('message', event => {
    if (!event.data) {
      return;
    }
    if (event.data.type === _constants.swMsgs.getClientsInfo) {
      (0, _utils.getClientsInfo)(event);
    }

    // Can be used upon first SW activation
    if (event.data.type === _constants.swMsgs.claimClients) {
      (0, _utils.claimClients)();
    }

    // This allows the web app to trigger skipWaiting via
    // registration.waiting.postMessage({type: 'SKIP_WAITING'})
    if (event.data.type === _constants.swMsgs.skipWaiting) {
      self.skipWaiting();
    }

    // Immediately trigger this throttled function -- this allows the app
    // to get the value ASAP upon startup, which it otherwise usually
    // has to wait for
    if (event.data.type === _constants.swMsgs.getImmediateDhis2ConnectionStatusUpdate) {
      _dhis2ConnectionStatus.broadcastDhis2ConnectionStatus.flush();
    }
    if (event.data.type === _constants.swMsgs.startRecording) {
      (0, _recordingMode.startRecording)(event);
    }
    if (event.data.type === _constants.swMsgs.completeRecording) {
      (0, _recordingMode.completeRecording)(event.source.id); // same as FetchEvent.clientId
    }
  });

  // Open DB on activation
  self.addEventListener('activate', event => {
    event.waitUntil((0, _utils.createDB)().then(_utils.removeUnusedCaches));
  });
}