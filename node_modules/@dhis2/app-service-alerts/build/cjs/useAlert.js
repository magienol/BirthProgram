"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useAlert = void 0;
var _react = require("react");
var _AlertsManagerContext = require("./AlertsManagerContext");
const useAlert = function (message) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const {
    add,
    plugin,
    parentAlertsAdd,
    showAlertsInPlugin
  } = (0, _react.useContext)(_AlertsManagerContext.AlertsManagerContext);
  const alertRef = (0, _react.useRef)(null);
  const show = (0, _react.useCallback)(props => {
    const resolvedMessage = String(typeof message === 'function' ? message(props) : message);
    const resolvedOptions = typeof options === 'function' ? options(props) : options;
    if (plugin && parentAlertsAdd && !showAlertsInPlugin) {
      var _parentAlertsAdd;
      // Functions passed through post-robot are asynchronous
      (_parentAlertsAdd = parentAlertsAdd({
        message: resolvedMessage,
        options: resolvedOptions
      }, alertRef
      // Conditional chaining gives backwards compatibility
      // with cli-app-scripts < 12
      )) === null || _parentAlertsAdd === void 0 ? void 0 : _parentAlertsAdd.then(newAlert => {
        alertRef.current = newAlert;
      });
    } else {
      alertRef.current = add({
        message: resolvedMessage,
        options: resolvedOptions
      }, alertRef);
    }
  }, [add, parentAlertsAdd, message, options, plugin, showAlertsInPlugin]);
  const hide = (0, _react.useCallback)(() => {
    var _alertRef$current, _alertRef$current$rem;
    (_alertRef$current = alertRef.current) === null || _alertRef$current === void 0 ? void 0 : (_alertRef$current$rem = _alertRef$current.remove) === null || _alertRef$current$rem === void 0 ? void 0 : _alertRef$current$rem.call(_alertRef$current);
  }, []);
  return {
    show,
    hide
  };
};
exports.useAlert = useAlert;