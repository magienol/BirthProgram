import { AlertsManagerContext } from '@dhis2/app-service-alerts';
import { useDataQuery } from '@dhis2/app-service-data';
import postRobot from 'post-robot';
import React, { useContext, useEffect, useMemo, useRef, useState } from 'react';
import PluginError from './PluginError';
const appsInfoQuery = {
  apps: {
    resource: 'apps'
  }
};

// sample logic subject to change depending on actual endpoint details
const getPluginEntryPoint = _ref => {
  var _apps$find;
  let {
    apps,
    appShortName
  } = _ref;
  return (_apps$find = apps.find(_ref2 => {
    let {
      short_name
    } = _ref2;
    return short_name && short_name === appShortName;
  })) === null || _apps$find === void 0 ? void 0 : _apps$find.pluginLaunchUrl;
};
export const Plugin = _ref3 => {
  let {
    pluginSource,
    pluginShortName,
    onLoad,
    height,
    width,
    className,
    clientWidth,
    ...propsToPassNonMemoized
  } = _ref3;
  const iframeRef = useRef(null);
  const {
    add: alertsAdd
  } = useContext(AlertsManagerContext);
  const {
    data
  } = useDataQuery(appsInfoQuery);
  const pluginEntryPoint = pluginSource !== null && pluginSource !== void 0 ? pluginSource : getPluginEntryPoint({
    apps: (data === null || data === void 0 ? void 0 : data.apps) || [],
    appShortName: pluginShortName
  });
  const [inErrorState, setInErrorState] = useState(false);
  // These are height and width values to be set by callbacks passed to the
  // plugin (these default sizes will be quickly overwritten by the plugin).
  // In order to behave like a normal block element, by default, the height
  // will be set by plugin contents, and this state will be used
  const [resizedHeight, setPluginHeight] = useState(150);
  // ...and by default, plugin width will be defined by the container
  // (width = 100%), so this state won't be used unless the `clientWidth`
  // prop is used to have plugin width defined by plugin contents
  const [resizedWidth, setPluginWidth] = useState(500);

  // since we do not know what props are passed, the dependency array has to be keys of whatever is standard prop
  // we exclude height/width from memoization to avoid updates for these properties
  const memoizedPropsToPass = useMemo(() => propsToPassNonMemoized, /* eslint-disable react-hooks/exhaustive-deps */
  [...Object.keys(propsToPassNonMemoized).sort().map(k => propsToPassNonMemoized[k])]
  /* eslint-enable react-hooks/exhaustive-deps */);

  // Used to track changes to the plugin source
  const prevEntryPointRef = useRef(pluginEntryPoint);
  // Becomes `true` when we get the first message from a plugin, so we know
  // it's ready to send messages to
  const communicationReceivedRef = useRef(false);

  // If plugin source changes, reset communicationReceived so new listeners
  // can be set up on the new window. This also helps avoid sending prop
  // updates meant for the new window to the old one
  useEffect(() => {
    if (pluginEntryPoint !== prevEntryPointRef.current) {
      communicationReceivedRef.current = false;
      prevEntryPointRef.current = pluginEntryPoint;
    }
  }, [pluginEntryPoint]);

  // Tracking these as booleans means they can be used as dependencies for
  // the useEffect to update props without triggering updates everytime their
  // string/number value changes
  const heightIsContentDriven = !height;
  const widthIsContentDriven = !width && clientWidth;

  // Set up communication listeners: if we haven't gotten a message from the
  // plugin, set up a listener for its request for initial props. If we have
  // received communication from the plugin, then on any props update, we can
  // send them to the plugin
  useEffect(() => {
    if (!iframeRef.current) {
      return;
    }
    const iframeProps = {
      ...memoizedPropsToPass,
      alertsAdd,
      // If a dimension is either specified or container-driven,
      // don't send a resize callback to the plugin. The plugin can
      // use the presence or absence of these callbacks to determine
      // how to handle sizing inside
      setPluginHeight: heightIsContentDriven ? setPluginHeight : null,
      setPluginWidth: widthIsContentDriven ? setPluginWidth : null,
      setInErrorState,
      clientWidth
    };

    // If iframe has not sent initial request, set up a listener
    // (this will still be set up if plugin needs to reload)
    if (!communicationReceivedRef.current && !inErrorState) {
      const listener = postRobot.on('getPropsFromParent',
      // listen for messages coming only from the iframe rendered by this component
      {
        window: iframeRef.current.contentWindow
      }, () => {
        communicationReceivedRef.current = true;
        return iframeProps;
      });
      return () => listener.cancel();
    }

    // If iframe has sent initial request, send new props
    if (communicationReceivedRef.current && iframeRef.current.contentWindow && !inErrorState) {
      postRobot.send(iframeRef.current.contentWindow, 'updated', iframeProps).catch(err => {
        // log postRobot errors, but do not bubble them up
        console.error(err);
      });
    }
  }, [memoizedPropsToPass, inErrorState, alertsAdd, heightIsContentDriven, widthIsContentDriven, clientWidth]);
  if (data && !pluginEntryPoint) {
    return /*#__PURE__*/React.createElement(PluginError, {
      missingEntryPoint: true,
      appShortName: pluginShortName
    });
  }
  if (!pluginEntryPoint) {
    return /*#__PURE__*/React.createElement(React.Fragment, null);
  }
  return /*#__PURE__*/React.createElement("iframe", {
    ref: iframeRef,
    src: pluginEntryPoint
    // Styles can be added via className. Sizing styles will take
    // precedence over the `width` and `height` props
    ,
    className: className
    // If clientWidth is set, then we want width to be set by plugin
    // (resizedWidth). Thereafter, if a width is specified, use that
    // Otherwise, use a specified width, or 100% by default
    ,
    width: clientWidth ? resizedWidth : width !== null && width !== void 0 ? width : '100%',
    height: height !== null && height !== void 0 ? height : resizedHeight,
    style: {
      border: 'none'
    },
    onLoad: onLoad
  });
};