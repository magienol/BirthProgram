"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Plugin = void 0;
var _appServiceAlerts = require("@dhis2/app-service-alerts");
var _appServiceData = require("@dhis2/app-service-data");
var _postRobot = _interopRequireDefault(require("post-robot"));
var _react = _interopRequireWildcard(require("react"));
var _PluginError = _interopRequireDefault(require("./PluginError"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const appsInfoQuery = {
  apps: {
    resource: 'apps'
  }
};

// sample logic subject to change depending on actual endpoint details
const getPluginEntryPoint = _ref => {
  var _apps$find;
  let {
    apps,
    appShortName
  } = _ref;
  return (_apps$find = apps.find(_ref2 => {
    let {
      short_name
    } = _ref2;
    return short_name && short_name === appShortName;
  })) === null || _apps$find === void 0 ? void 0 : _apps$find.pluginLaunchUrl;
};
const Plugin = _ref3 => {
  let {
    pluginSource,
    pluginShortName,
    onLoad,
    height,
    width,
    className,
    clientWidth,
    ...propsToPassNonMemoized
  } = _ref3;
  const iframeRef = (0, _react.useRef)(null);
  const {
    add: alertsAdd
  } = (0, _react.useContext)(_appServiceAlerts.AlertsManagerContext);
  const {
    data
  } = (0, _appServiceData.useDataQuery)(appsInfoQuery);
  const pluginEntryPoint = pluginSource !== null && pluginSource !== void 0 ? pluginSource : getPluginEntryPoint({
    apps: (data === null || data === void 0 ? void 0 : data.apps) || [],
    appShortName: pluginShortName
  });
  const [inErrorState, setInErrorState] = (0, _react.useState)(false);
  // These are height and width values to be set by callbacks passed to the
  // plugin (these default sizes will be quickly overwritten by the plugin).
  // In order to behave like a normal block element, by default, the height
  // will be set by plugin contents, and this state will be used
  const [resizedHeight, setPluginHeight] = (0, _react.useState)(150);
  // ...and by default, plugin width will be defined by the container
  // (width = 100%), so this state won't be used unless the `clientWidth`
  // prop is used to have plugin width defined by plugin contents
  const [resizedWidth, setPluginWidth] = (0, _react.useState)(500);

  // since we do not know what props are passed, the dependency array has to be keys of whatever is standard prop
  // we exclude height/width from memoization to avoid updates for these properties
  const memoizedPropsToPass = (0, _react.useMemo)(() => propsToPassNonMemoized, /* eslint-disable react-hooks/exhaustive-deps */
  [...Object.keys(propsToPassNonMemoized).sort().map(k => propsToPassNonMemoized[k])]
  /* eslint-enable react-hooks/exhaustive-deps */);

  // Used to track changes to the plugin source
  const prevEntryPointRef = (0, _react.useRef)(pluginEntryPoint);
  // Becomes `true` when we get the first message from a plugin, so we know
  // it's ready to send messages to
  const communicationReceivedRef = (0, _react.useRef)(false);

  // If plugin source changes, reset communicationReceived so new listeners
  // can be set up on the new window. This also helps avoid sending prop
  // updates meant for the new window to the old one
  (0, _react.useEffect)(() => {
    if (pluginEntryPoint !== prevEntryPointRef.current) {
      communicationReceivedRef.current = false;
      prevEntryPointRef.current = pluginEntryPoint;
    }
  }, [pluginEntryPoint]);

  // Tracking these as booleans means they can be used as dependencies for
  // the useEffect to update props without triggering updates everytime their
  // string/number value changes
  const heightIsContentDriven = !height;
  const widthIsContentDriven = !width && clientWidth;

  // Set up communication listeners: if we haven't gotten a message from the
  // plugin, set up a listener for its request for initial props. If we have
  // received communication from the plugin, then on any props update, we can
  // send them to the plugin
  (0, _react.useEffect)(() => {
    if (!iframeRef.current) {
      return;
    }
    const iframeProps = {
      ...memoizedPropsToPass,
      alertsAdd,
      // If a dimension is either specified or container-driven,
      // don't send a resize callback to the plugin. The plugin can
      // use the presence or absence of these callbacks to determine
      // how to handle sizing inside
      setPluginHeight: heightIsContentDriven ? setPluginHeight : null,
      setPluginWidth: widthIsContentDriven ? setPluginWidth : null,
      setInErrorState,
      clientWidth
    };

    // If iframe has not sent initial request, set up a listener
    // (this will still be set up if plugin needs to reload)
    if (!communicationReceivedRef.current && !inErrorState) {
      const listener = _postRobot.default.on('getPropsFromParent',
      // listen for messages coming only from the iframe rendered by this component
      {
        window: iframeRef.current.contentWindow
      }, () => {
        communicationReceivedRef.current = true;
        return iframeProps;
      });
      return () => listener.cancel();
    }

    // If iframe has sent initial request, send new props
    if (communicationReceivedRef.current && iframeRef.current.contentWindow && !inErrorState) {
      _postRobot.default.send(iframeRef.current.contentWindow, 'updated', iframeProps).catch(err => {
        // log postRobot errors, but do not bubble them up
        console.error(err);
      });
    }
  }, [memoizedPropsToPass, inErrorState, alertsAdd, heightIsContentDriven, widthIsContentDriven, clientWidth]);
  if (data && !pluginEntryPoint) {
    return /*#__PURE__*/_react.default.createElement(_PluginError.default, {
      missingEntryPoint: true,
      appShortName: pluginShortName
    });
  }
  if (!pluginEntryPoint) {
    return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null);
  }
  return /*#__PURE__*/_react.default.createElement("iframe", {
    ref: iframeRef,
    src: pluginEntryPoint
    // Styles can be added via className. Sizing styles will take
    // precedence over the `width` and `height` props
    ,
    className: className
    // If clientWidth is set, then we want width to be set by plugin
    // (resizedWidth). Thereafter, if a width is specified, use that
    // Otherwise, use a specified width, or 100% by default
    ,
    width: clientWidth ? resizedWidth : width !== null && width !== void 0 ? width : '100%',
    height: height !== null && height !== void 0 ? height : resizedHeight,
    style: {
      border: 'none'
    },
    onLoad: onLoad
  });
};
exports.Plugin = Plugin;