"use strict";

var _react = require("@testing-library/react");
var _react2 = _interopRequireDefault(require("react"));
var _testMocks = require("../../utils/test-mocks");
var _cacheableSection = require("../cacheable-section");
var _offlineProvider = require("../offline-provider");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
// Suppress 'act' warning for these tests
const originalError = console.error;
beforeEach(() => {
  jest.spyOn(console, 'error').mockImplementation(function () {
    const pattern = /Warning: An update to .* inside a test was not wrapped in act/;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (typeof args[0] === 'string' && pattern.test(args[0])) {
      return;
    }
    return originalError.call(console, ...args);
  });
});
afterEach(() => {
  jest.clearAllMocks()
  // This syntax appeases typescript:
  ;
  console.error.mockRestore();
});
it('renders in the default state initially', () => {
  const wrapper = _ref => {
    let {
      children
    } = _ref;
    return /*#__PURE__*/_react2.default.createElement(_offlineProvider.OfflineProvider, {
      offlineInterface: _testMocks.mockOfflineInterface
    }, children);
  };
  const {
    result
  } = (0, _react.renderHook)(() => (0, _cacheableSection.useCacheableSection)('one'), {
    wrapper
  });
  expect(result.current.recordingState).toBe('default');
  expect(result.current.isCached).toBe(false);
  expect(result.current.lastUpdated).toBeUndefined();
});
it('has stable references', () => {
  const wrapper = _ref2 => {
    let {
      children
    } = _ref2;
    return /*#__PURE__*/_react2.default.createElement(_offlineProvider.OfflineProvider, {
      offlineInterface: _testMocks.mockOfflineInterface
    }, children);
  };
  const {
    result,
    rerender
  } = (0, _react.renderHook)(() => (0, _cacheableSection.useCacheableSection)('one'), {
    wrapper
  });
  const origRecordingState = result.current.recordingState;
  const origStartRecording = result.current.startRecording;
  const origLastUpdated = result.current.lastUpdated;
  const origIsCached = result.current.isCached;
  const origRemove = result.current.remove;
  rerender();
  expect(result.current.recordingState).toBe(origRecordingState);
  expect(result.current.startRecording).toBe(origStartRecording);
  expect(result.current.lastUpdated).toBe(origLastUpdated);
  expect(result.current.isCached).toBe(origIsCached);
  expect(result.current.remove).toBe(origRemove);
});
it('handles a successful recording', async done => {
  const [sectionId, timeoutDelay] = ['one', 1234];
  const recordingSuccessOfflineInterface = {
    ..._testMocks.mockOfflineInterface,
    getCachedSections: jest.fn().mockResolvedValueOnce([]).mockResolvedValueOnce([{
      sectionId: sectionId,
      lastUpdated: new Date()
    }])
  };
  const wrapper = _ref3 => {
    let {
      children
    } = _ref3;
    return /*#__PURE__*/_react2.default.createElement(_offlineProvider.OfflineProvider, {
      offlineInterface: recordingSuccessOfflineInterface
    }, children);
  };
  const {
    result
  } = (0, _react.renderHook)(() => (0, _cacheableSection.useCacheableSection)(sectionId), {
    wrapper
  });
  const assertRecordingStarted = () => {
    expect(result.current.recordingState).toBe('recording');
  };
  const assertRecordingCompleted = async () => {
    expect(result.current.recordingState).toBe('default');

    // Test that 'isCached' gets updated
    expect(recordingSuccessOfflineInterface.getCachedSections).toBeCalledTimes(2);
    // Recording states are updated synchronously, but getting isCached
    // state is asynchronous -- need to wait for that here.
    // An assertion is not used as the waitFor condition because it may skew
    // the total number assertions in this test if it needs to retry. Number
    // of assertions is checked at the bottom of this test to make sure both
    // of these callbacks are called.
    await (0, _react.waitFor)(() => result.current.isCached === true);
    expect(result.current.isCached).toBe(true);
    expect(result.current.lastUpdated).toBeInstanceOf(Date);

    // If this cb is not called, test should time out and fail
    done();
  };
  await (0, _react.act)(async () => {
    await result.current.startRecording({
      onStarted: assertRecordingStarted,
      onCompleted: assertRecordingCompleted,
      recordingTimeoutDelay: timeoutDelay
    });
  });

  // At this stage, recording should be 'pending'
  expect(result.current.recordingState).toBe('pending');

  // Check correct options sent to offline interface
  const options = _testMocks.mockOfflineInterface.startRecording.mock.calls[0][0];
  expect(options.sectionId).toBe(sectionId);
  expect(options.recordingTimeoutDelay).toBe(timeoutDelay);
  expect(typeof options.onStarted).toBe('function');
  expect(typeof options.onCompleted).toBe('function');
  expect(typeof options.onError).toBe('function');

  // Make sure all async assertions are called
  expect.assertions(11);
});
it('handles a recording that encounters an error', async done => {
  // Suppress the expected error from console (in addition to 'act' warning)
  jest.spyOn(console, 'error').mockImplementation(function () {
    const actPattern = /Warning: An update to .* inside a test was not wrapped in act/;
    const errPattern = /Error during recording/;
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    const matchesPattern = actPattern.test(args[0]) || errPattern.test(args[0]);
    if (typeof args[0] === 'string' && matchesPattern) {
      return;
    }
    return originalError.call(console, ...args);
  });
  const recordingErrorOfflineInterface = {
    ..._testMocks.mockOfflineInterface,
    startRecording: _testMocks.errorRecordingMock
  };
  const wrapper = _ref4 => {
    let {
      children
    } = _ref4;
    return /*#__PURE__*/_react2.default.createElement(_offlineProvider.OfflineProvider, {
      offlineInterface: recordingErrorOfflineInterface
    }, children);
  };
  const {
    result
  } = (0, _react.renderHook)(() => (0, _cacheableSection.useCacheableSection)('one'), {
    wrapper
  });
  const assertRecordingStarted = () => {
    expect(result.current.recordingState).toBe('recording');
  };
  const assertRecordingError = error => {
    expect(result.current.recordingState).toBe('error');
    expect(error.message).toMatch(/test err/); // see errorRecordingMock
    expect(console.error).toHaveBeenCalledWith('Error during recording:', error);

    // Expect only one call, from initialization:
    expect(_testMocks.mockOfflineInterface.getCachedSections).toBeCalledTimes(1);

    // If this cb is not called, test should time out and fail
    done();
  };
  await (0, _react.act)(async () => {
    await result.current.startRecording({
      onStarted: assertRecordingStarted,
      onError: assertRecordingError
    });
  });

  // At this stage, recording should be 'pending'
  expect(result.current.recordingState).toBe('pending');

  // Make sure all async assertions are called
  expect.assertions(6);
});
it('handles an error starting the recording', async () => {
  const messageErrorOfflineInterface = {
    ..._testMocks.mockOfflineInterface,
    startRecording: _testMocks.failedMessageRecordingMock
  };
  const wrapper = _ref5 => {
    let {
      children
    } = _ref5;
    return /*#__PURE__*/_react2.default.createElement(_offlineProvider.OfflineProvider, {
      offlineInterface: messageErrorOfflineInterface
    }, children);
  };
  const {
    result
  } = (0, _react.renderHook)(() => (0, _cacheableSection.useCacheableSection)('err'), {
    wrapper
  });
  await expect(result.current.startRecording()).rejects.toThrow('Failed message' // from failedMessageRecordingMock
  );
});
it('handles remove and updates sections', async () => {
  const sectionId = 'one';
  const sectionOpsOfflineInterface = {
    ..._testMocks.mockOfflineInterface,
    getCachedSections: jest.fn().mockResolvedValueOnce([{
      sectionId: sectionId,
      lastUpdated: new Date()
    }]).mockResolvedValueOnce([])
  };
  const wrapper = _ref6 => {
    let {
      children
    } = _ref6;
    return /*#__PURE__*/_react2.default.createElement(_offlineProvider.OfflineProvider, {
      offlineInterface: sectionOpsOfflineInterface
    }, children);
  };
  const {
    result
  } = (0, _react.renderHook)(() => (0, _cacheableSection.useCacheableSection)(sectionId), {
    wrapper
  });

  // Wait for state to sync with indexedDB
  await (0, _react.waitFor)(() => expect(result.current.isCached).toBe(true));
  let success;
  await (0, _react.act)(async () => {
    success = await result.current.remove();
  });
  expect(success).toBe(true);
  // Test that 'isCached' gets updated
  expect(sectionOpsOfflineInterface.getCachedSections).toBeCalledTimes(2);
  await (0, _react.waitFor)(() => expect(result.current.isCached).toBe(false));
  expect(result.current.isCached).toBe(false);
  expect(result.current.lastUpdated).toBeUndefined();
});
it('handles a change in ID', async () => {
  const idChangeOfflineInterface = {
    ..._testMocks.mockOfflineInterface,
    getCachedSections: jest.fn().mockResolvedValue([{
      sectionId: 'id-one',
      lastUpdated: new Date()
    }])
  };
  const wrapper = _ref7 => {
    let {
      children
    } = _ref7;
    return /*#__PURE__*/_react2.default.createElement(_offlineProvider.OfflineProvider, {
      offlineInterface: idChangeOfflineInterface
    }, children);
  };
  const {
    result,
    rerender
  } = (0, _react.renderHook)(id => (0, _cacheableSection.useCacheableSection)(id), {
    wrapper,
    initialProps: 'id-one'
  });

  // Wait for state to sync with indexedDB
  await (0, _react.waitFor)(() => expect(result.current.isCached).toBe(true));
  rerender('id-two');

  // Test that 'isCached' gets updated
  // expect(idChangeOfflineInterface.getCachedSections).toBeCalledTimes(2)
  await (0, _react.waitFor)(() => expect(result.current.isCached).toBe(false));
  expect(result.current.isCached).toBe(false);
  expect(result.current.lastUpdated).toBeUndefined();
});