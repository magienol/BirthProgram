"use strict";

var _react = require("@testing-library/react");
var _react2 = _interopRequireDefault(require("react"));
var _testMocks = require("../../utils/test-mocks");
var _cacheableSectionState = require("../cacheable-section-state");
var _offlineProvider = require("../offline-provider");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const wrapper = _ref => {
  let {
    children
  } = _ref;
  return /*#__PURE__*/_react2.default.createElement(_offlineProvider.OfflineProvider, {
    offlineInterface: _testMocks.mockOfflineInterface
  }, children);
};
test('useRecordingState has stable references', () => {
  const {
    result,
    rerender
  } = (0, _react.renderHook)(() => (0, _cacheableSectionState.useRecordingState)('one'), {
    wrapper
  });
  const origRecordingState = result.current.recordingState;
  const origSetRecordingState = result.current.setRecordingState;
  const origRemoveRecordingState = result.current.removeRecordingState;
  rerender();
  expect(result.current.recordingState).toBe(origRecordingState);
  expect(result.current.setRecordingState).toBe(origSetRecordingState);
  expect(result.current.removeRecordingState).toBe(origRemoveRecordingState);
});
test('useCachedSection has stable references', () => {
  const {
    result,
    rerender
  } = (0, _react.renderHook)(() => (0, _cacheableSectionState.useCachedSection)('one'), {
    wrapper
  });
  const origIsCached = result.current.isCached;
  const origLastUpdated = result.current.lastUpdated;
  const origRemove = result.current.remove;
  const origSyncCachedSections = result.current.syncCachedSections;
  rerender();
  expect(result.current.isCached).toBe(origIsCached);
  expect(result.current.lastUpdated).toBe(origLastUpdated);
  expect(result.current.remove).toBe(origRemove);
  expect(result.current.syncCachedSections).toBe(origSyncCachedSections);
});