"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CacheableSectionProvider = CacheableSectionProvider;
exports.createCacheableSectionStore = createCacheableSectionStore;
exports.useCachedSection = useCachedSection;
exports.useCachedSections = useCachedSections;
exports.useRecordingState = useRecordingState;
var _propTypes = _interopRequireDefault(require("prop-types"));
var _react = _interopRequireWildcard(require("react"));
var _globalStateService = require("./global-state-service");
var _offlineInterface = require("./offline-interface");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
// Functions in here use the global state service to manage cacheable section
// state in a performant way

/**
 * Helper that transforms an array of cached section objects from the IndexedDB
 * into an object of values keyed by section ID
 *
 * @param {Array} list - An array of section objects
 * @returns {Object} An object of sections, keyed by ID
 */
function getSectionsById(sectionsArray) {
  return sectionsArray.reduce((result, _ref) => {
    let {
      sectionId,
      lastUpdated
    } = _ref;
    return {
      ...result,
      [sectionId]: {
        lastUpdated
      }
    };
  }, {});
}

/**
 * Create a store for Cacheable Section state.
 * Expected to be used in app adapter
 */
function createCacheableSectionStore() {
  const initialState = {
    recordingStates: {},
    cachedSections: {}
  };
  return (0, _globalStateService.createStore)(initialState);
}

/**
 * Helper hook that returns a value that will persist between renders but makes
 * sure to only set its initial state once.
 * See https://gist.github.com/amcgee/42bb2fa6d5f79e607f00e6dccc733482
 */
function useConst(factory) {
  const ref = _react.default.useRef(null);
  if (ref.current === null) {
    ref.current = factory();
  }
  return ref.current;
}

/**
 * Provides context for a global state context which will track cached
 * sections' status and cacheable sections' recording states, which will
 * determine how that component will render. The provider will be a part of
 * the OfflineProvider.
 */
function CacheableSectionProvider(_ref2) {
  let {
    children
  } = _ref2;
  const offlineInterface = (0, _offlineInterface.useOfflineInterface)();
  const store = useConst(createCacheableSectionStore);

  // On load, get sections and add to store
  (0, _react.useEffect)(() => {
    if (offlineInterface) {
      offlineInterface.getCachedSections().then(sections => {
        store.mutate(state => ({
          ...state,
          cachedSections: getSectionsById(sections)
        }));
      });
    }
  }, [store, offlineInterface]);
  return /*#__PURE__*/_react.default.createElement(_globalStateService.GlobalStateProvider, {
    store: store
  }, children);
}
CacheableSectionProvider.propTypes = {
  children: _propTypes.default.node
};
/**
 * Uses an optimized global state to manage 'recording state' values without
 * unnecessarily rerendering all consuming components
 *
 * @param {String} id - ID of the cacheable section to track
 * @returns {Object} { recordingState: String, setRecordingState: Function, removeRecordingState: Function}
 */
function useRecordingState(id) {
  const recordingStateSelector = (0, _react.useCallback)(state => state.recordingStates[id], [id]);
  const [recordingState] = (0, _globalStateService.useGlobalState)(recordingStateSelector);
  const setRecordingStateMutationCreator = (0, _react.useCallback)(newState => state => ({
    ...state,
    recordingStates: {
      ...state.recordingStates,
      [id]: newState
    }
  }), [id]);
  const setRecordingState = (0, _globalStateService.useGlobalStateMutation)(setRecordingStateMutationCreator);
  const removeRecordingStateMutationCreator = (0, _react.useCallback)(() => state => {
    const recordingStates = {
      ...state.recordingStates
    };
    delete recordingStates[id];
    return {
      ...state,
      recordingStates
    };
  }, [id]);
  const removeRecordingState = (0, _globalStateService.useGlobalStateMutation)(removeRecordingStateMutationCreator);
  return (0, _react.useMemo)(() => ({
    recordingState,
    setRecordingState,
    removeRecordingState
  }), [recordingState, setRecordingState, removeRecordingState]);
}

/**
 * Returns a function that syncs cached sections in the global state
 * with IndexedDB, so that IndexedDB is the single source of truth
 *
 * @returns {Function} syncCachedSections
 */
function useSyncCachedSections() {
  const offlineInterface = (0, _offlineInterface.useOfflineInterface)();
  const setCachedSectionsMutationCreator = (0, _react.useCallback)(cachedSections => state => ({
    ...state,
    cachedSections
  }), []);
  const setCachedSections = (0, _globalStateService.useGlobalStateMutation)(setCachedSectionsMutationCreator);
  return (0, _react.useCallback)(async () => {
    const sections = await offlineInterface.getCachedSections();
    setCachedSections(getSectionsById(sections));
  }, [offlineInterface, setCachedSections]);
}
/**
 * Uses global state to manage an object of cached sections' statuses
 *
 * @returns {Object} { cachedSections: Object, removeSection: Function }
 */
function useCachedSections() {
  const [cachedSections] = (0, _globalStateService.useGlobalState)(state => state.cachedSections);
  const syncCachedSections = useSyncCachedSections();
  const offlineInterface = (0, _offlineInterface.useOfflineInterface)();

  /**
   * Uses offline interface to remove a section from IndexedDB and Cache
   * Storage.
   *
   * Returns a promise that resolves to `true` if a section is found and
   * deleted, or `false` if asection with the specified ID does not exist.
   */
  const removeById = (0, _react.useCallback)(async id => {
    const success = await offlineInterface.removeSection(id);
    if (success) {
      await syncCachedSections();
    }
    return success;
  }, [offlineInterface, syncCachedSections]);
  return (0, _react.useMemo)(() => ({
    cachedSections,
    removeById,
    syncCachedSections
  }), [cachedSections, removeById, syncCachedSections]);
}
/**
 * Uses global state to manage the cached status of just one section, which
 * prevents unnecessary rerenders of consuming components
 *
 * @param {String} id
 * @returns {Object} { lastUpdated: Date, remove: Function }
 */
function useCachedSection(id) {
  const [status] = (0, _globalStateService.useGlobalState)(state => state.cachedSections[id]);
  const syncCachedSections = useSyncCachedSections();
  const offlineInterface = (0, _offlineInterface.useOfflineInterface)();
  const lastUpdated = status && status.lastUpdated;

  /**
   * Uses offline interface to remove a section from IndexedDB and Cache
   * Storage.
   *
   * Returns `true` if a section is found and deleted, or `false` if a
   * section with the specified ID does not exist.
   */
  const remove = (0, _react.useCallback)(async () => {
    const success = await offlineInterface.removeSection(id);
    if (success) {
      await syncCachedSections();
    }
    return success;
  }, [offlineInterface, id, syncCachedSections]);
  return (0, _react.useMemo)(() => ({
    lastUpdated,
    isCached: !!lastUpdated,
    remove,
    syncCachedSections
  }), [lastUpdated, remove, syncCachedSections]);
}