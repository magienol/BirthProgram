function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
import { getMutationFetchType } from './helpers/getMutationFetchType';
import { resolveDynamicQuery } from './helpers/resolveDynamicQuery';
import { validateResourceQuery, validateResourceQueries } from './helpers/validate';
const reduceResponses = (responses, names) => responses.reduce((out, response, idx) => {
  out[names[idx]] = response;
  return out;
}, {});
export class DataEngine {
  constructor(link) {
    _defineProperty(this, "link", void 0);
    this.link = link;
  }
  query(query) {
    let {
      variables = {},
      signal,
      onComplete,
      onError
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const names = Object.keys(query);
    const queries = names.map(name => query[name]).map(q => resolveDynamicQuery(q, variables));
    validateResourceQueries(queries, names);
    return Promise.all(queries.map(q => {
      return this.link.executeResourceQuery('read', q, {
        signal
      });
    })).then(results => {
      const data = reduceResponses(results, names);
      onComplete && onComplete(data);
      return data;
    }).catch(error => {
      onError && onError(error);
      throw error;
    });
  }
  mutate(mutation) {
    let {
      variables = {},
      signal,
      onComplete,
      onError
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const query = resolveDynamicQuery(mutation, variables);
    const type = getMutationFetchType(mutation);
    validateResourceQuery(type, query);
    const result = this.link.executeResourceQuery(type, query, {
      signal
    });
    return result.then(data => {
      onComplete && onComplete(data);
      return data;
    }).catch(error => {
      onError && onError(error);
      throw error;
    });
  }
}
export default DataEngine;