"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setMomentLocale = exports.setI18nLocale = exports.setDocumentDirection = exports.parseLocale = void 0;
var _d2I18n = _interopRequireDefault(require("@dhis2/d2-i18n"));
var _moment = _interopRequireDefault(require("moment"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
// Init i18n namespace
const I18N_NAMESPACE = 'default';
_d2I18n.default.setDefaultNamespace(I18N_NAMESPACE);

/**
 * userSettings.keyUiLocale is expected to be formatted by Java's
 * Locale.toString():
 * https://docs.oracle.com/javase/8/docs/api/java/util/Locale.html#toString--
 * We can assume there are no Variants or Extensions to locales used by DHIS2
 * @param {Intl.Locale} locale
 */
const parseJavaLocale = locale => {
  const [language, region, script] = locale.split('_');
  let languageTag = language;
  if (script) {
    languageTag += `-${script}`;
  }
  if (region) {
    languageTag += `-${region}`;
  }
  return new Intl.Locale(languageTag);
};

/**
 * @param {UserSettings} userSettings
 * @returns Intl.Locale
 */
const parseLocale = userSettings => {
  try {
    // proposed property
    if (userSettings.keyUiLanguageTag) {
      return new Intl.Locale(userSettings.keyUiLanguageTag);
    }
    // legacy property
    if (userSettings.keyUiLocale) {
      return parseJavaLocale(userSettings.keyUiLocale);
    }
  } catch (err) {
    console.error('Unable to parse locale from user settings:', {
      userSettings
    });
  }

  // worst-case fallback
  return new Intl.Locale(window.navigator.language);
};

/**
 * Test locales for available translation files -- if they're not found,
 * try less-specific versions.
 * Both "Java Locale.toString()" and BCP 47 language tag formats are tested
 * @param {Intl.Locale} locale
 */
exports.parseLocale = parseLocale;
const setI18nLocale = locale => {
  const {
    language,
    script,
    region
  } = locale;
  const localeStringOptions = [];
  if (script && region) {
    localeStringOptions.push(`${language}_${region}_${script}`, `${language}-${script}-${region}` // NB: different order
    );
  }
  if (region) {
    localeStringOptions.push(`${language}_${region}`, `${language}-${region}`);
  }
  if (script) {
    localeStringOptions.push(`${language}_${script}`, `${language}-${script}`);
  }
  localeStringOptions.push(language);
  let localeStringWithTranslations;
  const unsuccessfulLocaleStrings = [];
  for (const localeString of localeStringOptions) {
    if (_d2I18n.default.hasResourceBundle(localeString, I18N_NAMESPACE)) {
      localeStringWithTranslations = localeString;
      break;
    }
    unsuccessfulLocaleStrings.push(localeString);
    // even though the localeString === language will be the default below,
    // it still tested here to provide feedback if translation files
    // are not found
  }
  if (unsuccessfulLocaleStrings.length > 0) {
    console.log(`Translations for locale(s) ${unsuccessfulLocaleStrings.join(', ')} not found`);
  }

  // if no translation files are found, still try to fall back to `language`
  const finalLocaleString = localeStringWithTranslations || language;
  _d2I18n.default.changeLanguage(finalLocaleString);
  console.log('ðŸ—º Global d2-i18n locale initialized:', finalLocaleString);
};

/**
 * Moment locales use a hyphenated, lowercase format.
 * Since not all locales are included in Moment, this
 * function tries permutations of the locale to find one that's supported.
 * NB: None of them use both a region AND a script.
 * @param {Intl.Locale} locale
 */
exports.setI18nLocale = setI18nLocale;
const setMomentLocale = async locale => {
  const {
    language,
    region,
    script
  } = locale;
  if (locale.language === 'en' || locale.baseName === 'en-US') {
    return; // this is Moment's default locale
  }
  const localeNameOptions = [];
  if (script) {
    localeNameOptions.push(`${language}-${script}`.toLowerCase());
  }
  if (region) {
    localeNameOptions.push(`${language}-${region}`.toLowerCase());
  }
  localeNameOptions.push(language);
  for (const localeName of localeNameOptions) {
    try {
      // Since Vite prefers importing the ESM form of moment, we need
      // to import the ESM form of the locales here to use the same
      // moment instance
      await Promise.resolve(`moment/dist/locale/${localeName}`).then(s => _interopRequireWildcard(require(s)));
      _moment.default.locale(localeName);
      break;
    } catch {
      continue;
    }
  }
};

/**
 * Sets the global direction based on the app's configured direction
 * (which should be done to affect modals, alerts, and other portal elements).
 * Defaults to 'ltr' if not set.
 * Note that the header bar will use the localeDirection regardless
 */
exports.setMomentLocale = setMomentLocale;
const setDocumentDirection = _ref => {
  let {
    localeDirection,
    configDirection
  } = _ref;
  // validate config direction (also handles `undefined`)
  if (!['auto', 'ltr', 'rtl'].includes(configDirection)) {
    document.documentElement.setAttribute('dir', 'ltr');
    return;
  }
  const globalDirection = configDirection === 'auto' ? localeDirection : configDirection;
  document.documentElement.setAttribute('dir', globalDirection);
};
exports.setDocumentDirection = setDocumentDirection;